// ============================================
// FILE: /app/lib/router/app_router.dart
// ============================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../features/home/home_screen.dart';
import '../features/onboarding/onboarding_screen.dart';
import '../features/theme/theme_preview_screen.dart';
import '../features/providers/providers_screen.dart';
import '../features/family/family_screen.dart';
import '../providers/app_provider.dart';

final appRouterProvider = Provider<GoRouter>((ref) {
  final isFirstRun = ref.watch(isFirstRunProvider);
  
  return GoRouter(
    initialLocation: isFirstRun ? '/onboarding' : '/home',
    routes: [
      GoRoute(
        path: '/home',
        builder: (context, state) => const HomeScreen(),
      ),
      GoRoute(
        path: '/onboarding',
        builder: (context, state) => const OnboardingScreen(),
      ),
      GoRoute(
        path: '/themes',
        builder: (context, state) => const ThemePreviewScreen(),
      ),
      GoRoute(
        path: '/providers',
        builder: (context, state) => const ProvidersScreen(),
      ),
      GoRoute(
        path: '/family',
        builder: (context, state) => const FamilyScreen(),
      ),
      GoRoute(
        path: '/invite/:token',
        builder: (context, state) {
          final token = state.pathParameters['token']!;
          return FamilyScreen(inviteToken: token);
        },
      ),
    ],
    errorBuilder: (context, state) => Scaffold(
      body: Center(
        child: Text('Page not found: ${state.error}'),
      ),
    ),
  );
});

// ============================================
// FILE: /app/lib/core/widgets/speech_preview_widget.dart
// ============================================

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import '../../config/internal_config.dart';
import '../../config/strings_config.dart';

class SpeechPreviewWidget extends StatelessWidget {
  final String text;
  final bool isListening;
  final double height;
  
  const SpeechPreviewWidget({
    Key? key,
    required this.text,
    required this.isListening,
    this.height = 120,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDarkMode = theme.brightness == Brightness.dark;
    final isHighContrast = _isHighContrastTheme(theme);
    
    return AnimatedContainer(
      duration: InternalConfig.animationDuration,
      height: height,
      decoration: BoxDecoration(
        color: theme.cardTheme.color ?? theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: isListening 
              ? theme.colorScheme.primary 
              : Colors.transparent,
          width: isHighContrast ? 3 : 2,
        ),
        boxShadow: isListening ? [
          BoxShadow(
            color: theme.colorScheme.primary.withOpacity(0.3),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ] : [],
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (text.isEmpty && isListening)
                _buildListeningIndicator(theme)
              else if (text.isEmpty)
                Text(
                  'Tap the button to start talking',
                  style: theme.textTheme.bodyLarge?.copyWith(
                    color: theme.textTheme.bodySmall?.color,
                    fontSize: _getTextSize(isHighContrast),
                  ),
                )
              else
                Text(
                  text,
                  style: theme.textTheme.bodyLarge?.copyWith(
                    fontSize: _getTextSize(isHighContrast),
                    fontWeight: FontWeight.w500,
                  ),
                ),
            ],
          ),
        ),
      ),
    ).animate(target: isListening ? 1.0 : 0.0)
      .scale(
        begin: const Offset(1, 1),
        end: const Offset(1.02, 1.02),
        duration: const Duration(seconds: 2),
        curve: Curves.easeInOut,
      );
  }
  
  Widget _buildListeningIndicator(ThemeData theme) {
    return Row(
      children: [
        Text(
          StringsConfig.listeningText,
          style: theme.textTheme.bodyLarge?.copyWith(
            fontSize: _getTextSize(false),
            fontStyle: FontStyle.italic,
          ),
        ),
        const SizedBox(width: 8),
        ..._buildAnimatedDots(theme),
      ],
    );
  }
  
  List<Widget> _buildAnimatedDots(ThemeData theme) {
    return List.generate(3, (index) {
      return Container(
        margin: const EdgeInsets.symmetric(horizontal: 2),
        child: Container(
          width: 8,
          height: 8,
          decoration: BoxDecoration(
            color: theme.colorScheme.primary,
            shape: BoxShape.circle,
          ),
        ).animate(
          onPlay: (controller) => controller.repeat(),
        ).scale(
          delay: Duration(milliseconds: index * 200),
          duration: const Duration(milliseconds: 600),
          curve: Curves.easeInOut,
          begin: const Offset(1, 1),
          end: const Offset(1.5, 1.5),
        ).then()
          .scale(
            duration: const Duration(milliseconds: 600),
            curve: Curves.easeInOut,
            begin: const Offset(1.5, 1.5),
            end: const Offset(1, 1),
          ),
      );
    }).toList();
  }
  
  double _getTextSize(bool isHighContrast) {
    return isHighContrast ? 22.0 : 18.0;
  }
  
  bool _isHighContrastTheme(ThemeData theme) {
    // Check if this is a high contrast theme based on colors
    final backgroundColor = theme.colorScheme.background;
    final textColor = theme.textTheme.bodyLarge?.color ?? Colors.black;
    
    // Pure black background with white text = high contrast dark
    if (backgroundColor == Colors.black && textColor == Colors.white) {
      return true;
    }
    
    // Very light background with dark text = high contrast light
    if (backgroundColor.computeLuminance() > 0.9 && 
        textColor.computeLuminance() < 0.2) {
      return true;
    }
    
    return false;
  }
}

// ============================================
// FILE: /app/lib/core/widgets/primary_button.dart
// ============================================

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_animate/flutter_animate.dart';
import '../../config/internal_config.dart';

class PrimaryButton extends StatefulWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final IconData? icon;
  final double? width;
  final double height;
  final bool hapticFeedback;
  
  const PrimaryButton({
    Key? key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.icon,
    this.width,
    this.height = 56,
    this.hapticFeedback = true,
  }) : super(key: key);
  
  @override
  State<PrimaryButton> createState() => _PrimaryButtonState();
}

class _PrimaryButtonState extends State<PrimaryButton> 
    with SingleTickerProviderStateMixin {
  bool _isPressed = false;
  
  void _handleTapDown(TapDownDetails details) {
    if (widget.hapticFeedback) {
      HapticFeedback.lightImpact();
    }
    setState(() => _isPressed = true);
  }
  
  void _handleTapUp(TapUpDetails details) {
    setState(() => _isPressed = false);
  }
  
  void _handleTapCancel() {
    setState(() => _isPressed = false);
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return GestureDetector(
      onTapDown: widget.isLoading ? null : _handleTapDown,
      onTapUp: widget.isLoading ? null : _handleTapUp,
      onTapCancel: _handleTapCancel,
      onTap: widget.isLoading ? null : widget.onPressed,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 150),
        width: widget.width,
        height: widget.height,
        transform: Matrix4.identity()
          ..scale(_isPressed ? 0.95 : 1.0),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              theme.colorScheme.primary,
              theme.colorScheme.primary.withOpacity(0.8),
            ],
          ),
          borderRadius: BorderRadius.circular(widget.height / 2),
          boxShadow: [
            BoxShadow(
              color: theme.colorScheme.primary.withOpacity(_isPressed ? 0.2 : 0.4),
              blurRadius: _isPressed ? 8 : 16,
              offset: Offset(0, _isPressed ? 2 : 4),
            ),
          ],
        ),
        child: Material(
          color: Colors.transparent,
          child: Center(
            child: widget.isLoading
                ? _buildLoadingIndicator()
                : _buildContent(theme),
          ),
        ),
      ),
    ).animate()
      .fadeIn(duration: InternalConfig.animationDuration)
      .scale(
        begin: const Offset(0.8, 0.8),
        end: const Offset(1, 1),
        duration: InternalConfig.animationDuration,
        curve: Curves.elasticOut,
      );
  }
  
  Widget _buildLoadingIndicator() {
    return SizedBox(
      width: 24,
      height: 24,
      child: CircularProgressIndicator(
        strokeWidth: 2,
        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
      ),
    );
  }
  
  Widget _buildContent(ThemeData theme) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        if (widget.icon != null) ...[
          Icon(
            widget.icon,
            color: Colors.white,
            size: 24,
          ),
          const SizedBox(width: 8),
        ],
        Text(
          widget.text,
          style: theme.textTheme.labelLarge?.copyWith(
            color: Colors.white,
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }
}

// ============================================
// FILE: /app/lib/core/widgets/loading_indicator.dart
// ============================================

import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import '../../config/internal_config.dart';

class LoadingIndicator extends StatelessWidget {
  final String? message;
  final double size;
  
  const LoadingIndicator({
    Key? key,
    this.message,
    this.size = 48,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: size,
          height: size,
          child: Stack(
            children: [
              // Outer ring
              Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: theme.colorScheme.primary.withOpacity(0.2),
                    width: 3,
                  ),
                ),
              ),
              // Animated gradient ring
              Container(
                child: CircularProgressIndicator(
                  strokeWidth: 3,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    theme.colorScheme.primary,
                  ),
                ),
              ).animate(
                onPlay: (controller) => controller.repeat(),
              ).rotate(
                duration: const Duration(seconds: 2),
                curve: Curves.linear,
              ),
              // Center pulse
              Center(
                child: Container(
                  width: size * 0.3,
                  height: size * 0.3,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary,
                    shape: BoxShape.circle,
                  ),
                ).animate(
                  onPlay: (controller) => controller.repeat(),
                ).scale(
                  duration: const Duration(seconds: 1),
                  curve: Curves.easeInOut,
                  begin: const Offset(0.8, 0.8),
                  end: const Offset(1.2, 1.2),
                ).then()
                  .scale(
                    duration: const Duration(seconds: 1),
                    curve: Curves.easeInOut,
                    begin: const Offset(1.2, 1.2),
                    end: const Offset(0.8, 0.8),
                  ),
              ),
            ],
          ),
        ),
        if (message != null) ...[
          const SizedBox(height: 16),
          Text(
            message!,
            style: theme.textTheme.bodyMedium,
            textAlign: TextAlign.center,
          ).animate()
            .fadeIn(delay: const Duration(milliseconds: 300)),
        ],
      ],
    );
  }
}

// ============================================
// FILE: /app/lib/core/utils/encryption_utils.dart
// ============================================

import 'dart:convert';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';
import 'dart:math';
import '../../config/internal_config.dart';

class EncryptionUtils {
  // Generate random salt
  static Uint8List generateSalt() {
    final random = Random.secure();
    final salt = Uint8List(InternalConfig.saltLength);
    for (int i = 0; i < salt.length; i++) {
      salt[i] = random.nextInt(256);
    }
    return salt;
  }
  
  // Generate random nonce for AES-GCM
  static Uint8List generateNonce() {
    final random = Random.secure();
    final nonce = Uint8List(InternalConfig.nonceLength);
    for (int i = 0; i < nonce.length; i++) {
      nonce[i] = random.nextInt(256);
    }
    return nonce;
  }
  
  // Derive key using PBKDF2
  static Uint8List deriveKey(String password, Uint8List salt) {
    // This is a simplified version - in production, use a proper PBKDF2 implementation
    // You would typically use a package like pointycastle for this
    final hmac = Hmac(sha256, utf8.encode(password));
    final digest = hmac.convert(salt);
    return Uint8List.fromList(digest.bytes);
  }
  
  // Encrypt data (simplified - use proper AES-GCM in production)
  static Map<String, String> encrypt(String plaintext, String password) {
    final salt = generateSalt();
    final nonce = generateNonce();
    final key = deriveKey(password, salt);
    
    // This is a placeholder - implement proper AES-GCM encryption
    // In production, use a package like encrypt or pointycastle
    final encrypted = base64.encode(utf8.encode(plaintext));
    
    return {
      'ciphertext': encrypted,
      'salt': base64.encode(salt),
      'nonce': base64.encode(nonce),
      'algorithm': 'AES-GCM-256',
      'kdf': 'PBKDF2-HMAC-SHA256',
      'iterations': InternalConfig.pbkdf2Iterations.toString(),
    };
  }
  
  // Decrypt data (simplified - use proper AES-GCM in production)
  static String decrypt(Map<String, String> encryptedData, String password) {
    final salt = base64.decode(encryptedData['salt']!);
    final nonce = base64.decode(encryptedData['nonce']!);
    final ciphertext = encryptedData['ciphertext']!;
    
    final key = deriveKey(password, salt);
    
    // This is a placeholder - implement proper AES-GCM decryption
    // In production, use a package like encrypt or pointycastle
    final decrypted = utf8.decode(base64.decode(ciphertext));
    
    return decrypted;
  }
}

// ============================================
// FILE: /app/lib/core/services/api_service.dart
// ============================================

import 'dart:convert';
import 'package:dio/dio.dart';
import '../../config/internal_config.dart';

class ApiService {
  late final Dio _dio;
  static final ApiService _instance = ApiService._internal();
  
  factory ApiService() => _instance;
  
  ApiService._internal() {
    _dio = Dio(BaseOptions(
      baseUrl: InternalConfig.workerBaseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
      },
    ));
    
    // Add interceptors for logging in debug mode
    if (InternalConfig.showDebugMenu) {
      _dio.interceptors.add(LogInterceptor(
        requestBody: true,
        responseBody: true,
      ));
    }
  }
  
  // Chat with LLM
  Future<ChatResponse> chat({
    required String message,
    required String provider,
    required String deviceId,
  }) async {
    try {
      final response = await _dio.post('/api/chat', data: {
        'message': message,
        'provider': provider,
        'deviceId': deviceId,
      });
      
      return ChatResponse.fromJson(response.data);
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        throw Exception('Please add your API key for $provider');
      }
      throw Exception('Failed to send message: ${e.message}');
    }
  }
  
  // Save encrypted keys
  Future<void> saveKeys({
    required String deviceId,
    required Map<String, String> encryptedKeys,
  }) async {
    try {
      await _dio.post('/api/keys/save', data: {
        'deviceId': deviceId,
        'encryptedKeys': encryptedKeys,
      });
    } catch (e) {
      throw Exception('Failed to save keys: $e');
    }
  }
  
  // Get encrypted keys
  Future<Map<String, String>?> getKeys(String deviceId) async {
    try {
      final response = await _dio.get('/api/keys/get', queryParameters: {
        'deviceId': deviceId,
      });
      
      return Map<String, String>.from(response.data);
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        return null;
      }
      throw Exception('Failed to get keys: ${e.message}');
    }
  }
  
  // Create family invite
  Future<FamilyInvite> createInvite({
    required String deviceId,
    required String memberName,
  }) async {
    try {
      final response = await _dio.post('/api/family/create_invite', data: {
        'deviceId': deviceId,
        'memberName': memberName,
      });
      
      return FamilyInvite.fromJson(response.data);
    } catch (e) {
      throw Exception('Failed to create invite: $e');
    }
  }
  
  // Accept family invite
  Future<void> acceptInvite({
    required String token,
    required String deviceId,
    Map<String, dynamic>? deviceInfo,
  }) async {
    try {
      await _dio.post('/api/family/accept_invite', data: {
        'token': token,
        'deviceId': deviceId,
        'deviceInfo': deviceInfo,
      });
    } catch (e) {
      throw Exception('Failed to accept invite: $e');
    }
  }
  
  // Get family members
  Future<List<FamilyMemberData>> getFamilyMembers(String familyId) async {
    try {
      final response = await _dio.get('/api/family/list', queryParameters: {
        'familyId': familyId,
      });
      
      final data = response.data;
      final members = (data['members'] as List)
          .map((m) => FamilyMemberData.fromJson(m))
          .toList();
      
      return members;
    } catch (e) {
      throw Exception('Failed to get family members: $e');
    }
  }
}

// Response models
class ChatResponse {
  final String summary;
  final String fullResponse;
  final String modelUsed;
  final String? switchReason;
  
  ChatResponse({
    required this.summary,
    required this.fullResponse,
    required this.modelUsed,
    this.switchReason,
  });
  
  factory ChatResponse.fromJson(Map<String, dynamic> json) {
    return ChatResponse(
      summary: json['summary'],
      fullResponse: json['fullResponse'],
      modelUsed: json['modelUsed'],
      switchReason: json['switchReason'],
    );
  }
}

class FamilyInvite {
  final String token;
  final String familyId;
  final String inviteLink;
  final String expiresIn;
  
  FamilyInvite({
    required this.token,
    required this.familyId,
    required this.inviteLink,
    required this.expiresIn,
  });
  
  factory FamilyInvite.fromJson(Map<String, dynamic> json) {
    return FamilyInvite(
      token: json['token'],
      familyId: json['familyId'],
      inviteLink: json['inviteLink'],
      expiresIn: json['expiresIn'],
    );
  }
}

class FamilyMemberData {
  final String deviceId;
  final String name;
  final String role;
  final DateTime joinedAt;
  
  FamilyMemberData({
    required this.deviceId,
    required this.name,
    required this.role,
    required this.joinedAt,
  });
  
  factory FamilyMemberData.fromJson(Map<String, dynamic> json) {
    return FamilyMemberData(
      deviceId: json['deviceId'],
      name: json['name'],
      role: json['role'],
      joinedAt: DateTime.parse(json['joinedAt']),
    );
  }
}